"""Alert models for AgentsLeak.

These models represent security alerts and policies for detection.
"""

from __future__ import annotations

from datetime import UTC, datetime
from enum import StrEnum
from typing import Any
from uuid import UUID, uuid4

from pydantic import BaseModel, Field

from agentsleak.models.events import EventCategory, Severity


class AlertStatus(StrEnum):
    """Status of an alert."""

    NEW = "new"
    INVESTIGATING = "investigating"
    CONFIRMED = "confirmed"
    FALSE_POSITIVE = "false_positive"
    RESOLVED = "resolved"
    ESCALATED = "escalated"


class AlertEvidence(BaseModel):
    """Evidence associated with an alert."""

    event_id: UUID = Field(..., description="ID of the event that triggered this evidence")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(UTC))
    description: str = Field(..., description="Description of the evidence")
    data: dict[str, Any] = Field(default_factory=dict, description="Additional evidence data")
    file_path: str | None = None
    command: str | None = None
    url: str | None = None

    model_config = {"from_attributes": True}


class Alert(BaseModel):
    """A security alert generated by the detection engine."""

    id: UUID = Field(default_factory=uuid4)
    session_id: str = Field(..., description="Claude Code session ID")
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(UTC))

    # Alert classification
    title: str = Field(..., description="Short title for the alert")
    description: str = Field(..., description="Detailed description of the alert")
    severity: Severity = Field(default=Severity.MEDIUM)
    category: EventCategory = Field(default=EventCategory.UNKNOWN)

    # Status tracking
    status: AlertStatus = Field(default=AlertStatus.NEW)
    assigned_to: str | None = None

    # Related data
    policy_id: UUID | None = Field(None, description="Policy that triggered this alert")
    event_ids: list[UUID] = Field(default_factory=list, description="Related event IDs")
    evidence: list[AlertEvidence] = Field(default_factory=list)

    # Response actions taken
    action_taken: str | None = None
    blocked: bool = Field(default=False, description="Whether the action was blocked")

    # Additional context
    tags: list[str] = Field(default_factory=list)
    metadata: dict[str, Any] = Field(default_factory=dict)

    model_config = {"from_attributes": True}

    def add_evidence(
        self,
        event_id: UUID,
        description: str,
        data: dict[str, Any] | None = None,
        **kwargs: Any,
    ) -> None:
        """Add evidence to the alert."""
        evidence = AlertEvidence(
            event_id=event_id,
            description=description,
            data=data or {},
            **kwargs,
        )
        self.evidence.append(evidence)
        self.updated_at = datetime.now(UTC)


class ConditionOperator(StrEnum):
    """Operators for rule conditions."""

    EQUALS = "equals"
    NOT_EQUALS = "not_equals"
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    STARTS_WITH = "starts_with"
    ENDS_WITH = "ends_with"
    MATCHES = "matches"  # Regex match
    NOT_MATCHES = "not_matches"  # Negated regex match
    GREATER_THAN = "greater_than"
    LESS_THAN = "less_than"
    IN = "in"
    NOT_IN = "not_in"


class RuleCondition(BaseModel):
    """A condition for a policy rule."""

    field: str = Field(..., description="Field to evaluate (e.g., 'tool_name', 'file_path')")
    operator: ConditionOperator = Field(..., description="Comparison operator")
    value: Any = Field(..., description="Value to compare against")
    case_sensitive: bool = Field(default=False)

    model_config = {"from_attributes": True}

    def evaluate(self, data: dict[str, Any]) -> bool:
        """Evaluate this condition against the given data."""
        field_value = self._get_nested_field(data, self.field)
        if field_value is None:
            return False

        compare_value = self.value
        if not self.case_sensitive and isinstance(field_value, str):
            field_value = field_value.lower()
            if isinstance(compare_value, str) and self.operator not in (ConditionOperator.MATCHES, ConditionOperator.NOT_MATCHES):
                compare_value = compare_value.lower()

        match self.operator:
            case ConditionOperator.EQUALS:
                return field_value == compare_value
            case ConditionOperator.NOT_EQUALS:
                return field_value != compare_value
            case ConditionOperator.CONTAINS:
                return compare_value in str(field_value)
            case ConditionOperator.NOT_CONTAINS:
                return compare_value not in str(field_value)
            case ConditionOperator.STARTS_WITH:
                return str(field_value).startswith(str(compare_value))
            case ConditionOperator.ENDS_WITH:
                return str(field_value).endswith(str(compare_value))
            case ConditionOperator.MATCHES:
                import re

                try:
                    flags = re.IGNORECASE if not self.case_sensitive else 0
                    return bool(re.search(str(self.value), str(field_value), flags))
                except re.error:
                    return False
            case ConditionOperator.NOT_MATCHES:
                import re

                try:
                    flags = re.IGNORECASE if not self.case_sensitive else 0
                    return not bool(re.search(str(self.value), str(field_value), flags))
                except re.error:
                    return False
            case ConditionOperator.GREATER_THAN:
                return field_value > compare_value
            case ConditionOperator.LESS_THAN:
                return field_value < compare_value
            case ConditionOperator.IN:
                return field_value in compare_value
            case ConditionOperator.NOT_IN:
                return field_value not in compare_value
            case _:
                return False

    def _get_nested_field(self, data: dict[str, Any], field: str) -> Any:
        """Get a nested field value using dot notation."""
        parts = field.split(".")
        value = data
        for part in parts:
            if isinstance(value, dict):
                value = value.get(part)
            else:
                return None
        return value


class PolicyAction(StrEnum):
    """Action to take when a policy matches."""

    ALERT = "alert"
    BLOCK = "block"
    LOG = "log"
    NOTIFY = "notify"


class Policy(BaseModel):
    """A detection policy with rules and actions."""

    id: UUID = Field(default_factory=uuid4)
    name: str = Field(..., description="Policy name")
    description: str = Field(default="", description="Policy description")
    enabled: bool = Field(default=True)

    # Matching criteria
    categories: list[EventCategory] = Field(
        default_factory=list, description="Event categories to match"
    )
    tools: list[str] = Field(default_factory=list, description="Tool names to match")
    conditions: list[RuleCondition] = Field(
        default_factory=list, description="Additional conditions"
    )
    condition_logic: str = Field(
        default="all", description="Logic for conditions: 'all' or 'any'"
    )

    # Response configuration
    action: PolicyAction = Field(default=PolicyAction.ALERT)
    severity: Severity = Field(default=Severity.MEDIUM)
    alert_title: str = Field(default="Policy Violation Detected")
    alert_description: str = Field(default="")

    # Metadata
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    tags: list[str] = Field(default_factory=list)

    model_config = {"from_attributes": True}

    def matches(self, event_data: dict[str, Any]) -> bool:
        """Check if an event matches this policy."""
        if not self.enabled:
            return False

        # Check category
        if self.categories:
            event_category = event_data.get("category")
            if event_category not in [c.value for c in self.categories]:
                return False

        # Check tool name
        if self.tools:
            tool_name = event_data.get("tool_name")
            if tool_name not in self.tools:
                return False

        # Check conditions
        if self.conditions:
            if self.condition_logic == "all":
                return all(cond.evaluate(event_data) for cond in self.conditions)
            else:  # "any"
                return any(cond.evaluate(event_data) for cond in self.conditions)

        return True
